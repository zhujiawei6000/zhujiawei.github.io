---
layout: post
title:  "A Path Finding Implementation with Modern C++ (Part1)"
date:   2024-01-21 11:58:00
categories: C++
brief: "About 10 years ago, I implemented my first A* algorithm with C++98 version. Inspiring by Brian Cairl CppCon23 Presentation I try to implement one by myself in modern C++ fashion at my best. Enjoying.."
---

# Inroduction
Given a map and point A & B in this map, you want to figure out the shortest path from point A to point B. How to achieve this task? The map contains lots of obstacles, maybe a river you have to swim across, maybe a mountain you have to climb, and so on.. It's not only the shortest path, it's also the path that takes least efforts. In the computer science, there is a donzen of path finding algorithm includes A*, D* etc. In the first time, I will introduce the classic one - Dijkstra which was invent by Dr. Edsger W. Dijkstra In 1959. For the detail of the algorthim, there are so many on the internet, so I will not introduce here. I just recommand [Estefania Cassingena Navone's article](https://www.freecodecamp.org/news/dijkstras-shortest-path-algorithm-visual-introduction)
. After you have known the basic of the algorithm. Let's start implement one by yourself. 


# Implement
I will break all the implementation to the following parts

- Graph - Implement the data structure of the map
- GraphBuilder - Helper class which contains the utility to construct one 
- SearchContext - Provide all the intermedia data needed in one search procedure
- Algorithm - The main logic of the path finding algorithm

Besides the above, we also have one exampleï¼Œwhich put all the thing together. The full code is available on my github https://github.com/zhujiawei6000/path_finding. Let's dive to the detail.

![path-finding-demo](/img/2024-01-21_1.gif){:class="img-responsive"}

## Graph

graph is a common form of a map. The key concept of graph is node(vetex) and edge. In a simple word, the node represent a place on the map, and the edge represent the road connection. Each edge also has a weight, means the distance between two nodes. Here's the code.
```
namespace pf {
using NodeId = int;
struct NodeProperties {
  std::string name;
  ...
};
using CostType = int;
struct EdgeProperties {
  CostType cost;
  ...
};

using Edge = std::pair<NodeId, EdgeProperties>;
```
The node is very straight-forward just id and some custom properties. And the edge defined by std::pair of distination node and edge properties. edge properties includes cost of the edge and others.

Next, we define the graph with node and edge

```
class Graph {
 private:
  friend class GraphBuilder;
  std::multimap<NodeId, Edge> adjacencies_;
  std::map<NodeId, NodeProperties> nodes_;

 public:
  template <typename EdgeVisitorT>
  void ForEachEdge(NodeId key, EdgeVisitorT&& visitor) const {
    auto range = adjacencies_.equal_range(key);
    std::for_each(range.first, range.second,
                  [visitor](const auto& parent_and_edge) mutable {
                    std::apply(visitor, parent_and_edge.second);
                  });
  }
  const NodeProperties& Node(NodeId nid) const { return nodes_.at(nid); }
};
```

  using ```std::multimap<NodeId, Edge> ``` to store the relationship of the nodes - edges. and ```std::map<NodeId, NodeProperties>``` to store all the nodes and its props.
  
We also add ```ForEachEdge(NodeId key, EdgeVisitorT&& visitor)``` function as accessor for the internal data. The function find the adjacencies of the given node and apply visitor to all the adjacencies.

To be continued...

